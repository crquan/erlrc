#summary An explanation of erlrc

= Introduction =

One of Erlang's strengths is hot code loading, the ability to change the software on the system without interrupting service.  For internet applications this is especially powerful.

Hot code loading in Erlang consists of low-level language support, and a high-level strategy of [http://www.erlang.org/doc/design_principles/release_structure.html release handling] embodied in the OTP libraries.

erlrc embodies another high level strategy for using the low-level capabilities of Erlang for hot code loading.  Unlike release handling it is designed to be incremental and integrated into the OS package management.  The goal is an experience like this:
{{{
pmineiro@ub32srvvmw-199% sudo apt-get install egerl
Reading package lists... Done
Building dependency tree       
Reading state information... Done
The following packages will be upgraded:
  egerl
1 upgraded, 0 newly installed, 0 to remove and 34 not upgraded.
Need to get 0B/113kB of archives.
After unpacking 0B of additional disk space will be used.
WARNING: The following packages cannot be authenticated!  egerl
Install these packages without verification [y/N]? y
(Reading database ... 48221 files and directories currently installed.)
Preparing to replace egerl 4.0.1 (using .../archives/egerl_4.1.0_all.deb) ...
dpkg: warning - old pre-removal script returned error exit status 1
dpkg - trying script from the new package instead ...
dpkg: ... it looks like that went OK.
Unpacking replacement egerl ...
dpkg: warning - old post-removal script returned error exit status 1
dpkg - trying script from the new package instead ...
erlrc-upgrade: Upgrading 'egerl': (cb8eec1a1b85ec017517d3e51c5aee7b) upgraded
dpkg: ... it looks like that went OK.
Setting up egerl (4.1.0) ...
erlrc-start: Starting 'egerl': (cb8eec1a1b85ec017517d3e51c5aee7b) already_running
}}}
Basically, on the running Erlang node on my machine, the Erlang application egerl was hot-code upgraded from 4.0.1 to 4.1.0 when the package was installed.  If this were an initial install, it would have started the application instead.  The OS package manager takes care of dependencies and you end up managing Erlang the way you manage everything else.[[#1 1]] 

= Design =

Erlrc consists of two pieces, an upgrade piece, and a boot piece.

== Boot ==

Erlang uses a [http://www.erlang.org/doc/design_principles/release_structure.html#boot boot script] to decide what to do when starting up.  The situation is analogous to http servers such as Apache which, when first designed, used a single file for configuration.  This is a natural approach which unfortunately complicates package managed operating systems, since different packages have to manipulate the same file.  As with Apache, our solution involves controlling the boot process from a directory.  

$ERLRC_ROOT/applications contains a list of applications that should be run at boot time.  [http://code.google.com/p/erlrc/source/browse/trunk/src/erlrc_boot.erl erlrc_boot] sorts these applications in dependency order and then starts them.[[#2 2]]
{{{
% ls /etc/erlrc.d/applications
appinspect       egerl   fragmentron  genherd       nodefinder    zfile
combonodefinder  erlrc   fuserl       loggins       schemafinder
ec2nodefinder    erlsom  gencron      n54etsbugfix  virtuerl
}}}
By default $ERLRC_ROOT is /etc/erlrc.d .

You can of course start stuff in your boot script as well if you like, erlrc won't start something that's already started.  In practice we use the vanilla boot scripts and pass {{{-s erlrc_boot boot}}} to the erl command line.

Oh, everything works with included applications as well.  By "everything works", we mean that erlrc will look at the set of applications to start, will note any application {{{X}}} that includes another application {{{Y}}}, and will consider the requirement to start {{{Y}}} as being satisfied by starting {{{X}}}, and will only start {{{X}}}.

In practice, then, any package which provides an OTP application should place a file in $ERLRC_ROOT/applications/ to ensure that it gets started up at (Erlang) boot time.  The filename indicates the name of the application to start, and the contents of this file are not examined by erlrc.

== Package Installation ==

For package installation time, shell scripts are provided which are designed to be run from the packaging system's hooks.  These shell scripts ultimately invoke methods from [http://code.google.com/p/erlrc/source/browse/trunk/src/erlrcdynamic.erl erlrcdynamic], which contains methods for starting, stopping, upgrading, and downgrading individual OTP applications.  

These shell scripts look at $ERLRC_ROOT/nodes for a list of nodes to manage; the filenames are the node names (on the localhost) and the file contents are the node cookie.  
{{{
% ls /etc/erlrc.d/nodes
cb8eec1a1b85ec017517d3e51c5aee7b
}}}
We use md5sums to generate node names at our company, hence the funny node name.[[#3 3]]  

...

= Footnotes =

== 1 ==

If you have circular dependencies then you will have transients in your system when things aren't working while the installs happen.  We think (but are not sure) that the release handler has problems too, since the low-level primitives can only atomically upgrade one module at a time.  However maybe we're wrong about that.  In practice, we haven't have circular dependencies.

== 2 ==

There are two concepts of dependency here.  The first is an OS package manager dependency, the second is the OTP application specification dependency.  erlrcdynamic uses the former (implicitly, since it gets invoked by the OS package manager), and erlrc_boot uses the latter.  You have to arrange for both types of dependencies to be correct.

== 3 ==

I'm not going to show you the cookie, but it's basically {{{ cookie=`cat /etc/erlrc.d/nodes/cb8eec1a1b85ec017517d3e51c5aee7b` }}}.